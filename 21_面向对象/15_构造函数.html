<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			//构造函数
			function Person(name,age){
				this.name = name;
				this.age = age;
				this.run = function(){
					console.log(this.name+"\n"+this.age);
				}
			}
			var person1 = new Person("天下",18);
			//person1.run();
			var person2 = new Person("晓晓",22);
			console.log(person1);
			//person1 和 person2 分别保存着Person的一个不同的实例。
			//这两个对象都有一个constructor(构造函数)属性，
			//该属性指向Person
			
			//console.log(person1.constructor == Person);
			//console.log(person2.constructor == Person);
			
			//对象的constructor属性最初是用来标识对象类型的。
			//但是,提到检测对象类型,还是instanceof操作符更可靠一些.
			//我们在这个例子中创建的所有对象既是Object的实例,同时也是
			//Person的实例,这一点通过instanceof操作符可以得到验证.
			
			//console.log(person1 instanceof Person);  	//true
			//console.log(person1 instanceof Object);		//true
			//console.log(person2 instanceof Person);		//true
			//console.log(person2 instanceof Object);		//true
			
			//在另一个对象的作用域中调用
			var o = new Object();
			Person.call(o,"果果",18);
			o.run();  // 果果 18
			//可以使用call()或者apply()在某个特殊对象的作用域中调用Person()函数
			//这里在对象o的作用域中调用的,因此调用后o就拥有属性和run()方法
			
			
	
		</script>
	</body>
</html>
